<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sylvan &mdash; Sylvan 1.8.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            Sylvan
          </a>
              <div class="version">
                1.8.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Sylvan</a><ul>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
<li><a class="reference internal" href="#building">Building</a></li>
<li><a class="reference internal" href="#using-sylvan">Using Sylvan</a><ul>
<li><a class="reference internal" href="#the-lace-framework">The Lace framework</a></li>
<li><a class="reference internal" href="#garbage-collection-and-referencing-nodes">Garbage collection and referencing nodes</a></li>
<li><a class="reference internal" href="#basic-bdd-mtbdd-functionality">Basic BDD/MTBDD functionality</a></li>
<li><a class="reference internal" href="#custom-leaves">Custom leaves</a></li>
<li><a class="reference internal" href="#custom-decision-diagram-operations">Custom decision diagram operations</a></li>
<li><a class="reference internal" href="#list-decision-diagrams">List decision diagrams</a></li>
<li><a class="reference internal" href="#file-i-o">File I/O</a></li>
<li><a class="reference internal" href="#support-for-c">Support for C++</a></li>
<li><a class="reference internal" href="#table-resizing">Table resizing</a></li>
<li><a class="reference internal" href="#dynamic-reordering">Dynamic reordering</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#troubleshooting">Troubleshooting</a><ul>
<li><a class="reference internal" href="#i-am-getting-the-error-unable-to-allocate-memory">I am getting the error “unable to allocate memory: …!”</a></li>
<li><a class="reference internal" href="#i-get-errors-about-lace-worker-and-lace-dq-head">I get errors about <code class="docutils literal notranslate"><span class="pre">__lace_worker</span></code> and <code class="docutils literal notranslate"><span class="pre">__lace_dq_head</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#publications">Publications</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Sylvan</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Sylvan</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sylvan">
<h1>Sylvan<a class="headerlink" href="#sylvan" title="Permalink to this heading">¶</a></h1>
<p>Sylvan is a parallel (multi-core) MTBDD library written in C. Sylvan
implements parallelized operations on BDDs, MTBDDs and LDDs. Both
sequential and parallel BDD-based algorithms can benefit from
parallelism. Sylvan uses the work-stealing framework Lace and parallel
datastructures to implement scalable multi-core operations on decision
diagrams.</p>
<p>Sylvan is developed (© 2011-2016) by the <a class="reference external" href="http://fmt.ewi.utwente.nl/">Formal Methods and
Tools</a> group at the University of Twente
as part of the MaDriD project, which is funded by NWO, and (© 2016-2017)
by the <a class="reference external" href="http://fmv.jku.at/">Formal Methods and Verification</a> group at
the Johannes Kepler University Linz as part of the RiSE project. Sylvan
is licensed with the Apache 2.0 license.
The main author of the project is Tom van Dijk who can be reached via
<a class="reference external" href="mailto:tom&#37;&#52;&#48;tvandijk&#46;nl">tom<span>&#64;</span>tvandijk<span>&#46;</span>nl</a>.
Please let us know if you use Sylvan in your projects and if you need
decision diagram operations that are currently not implemented in Sylvan.</p>
<p>The main repository of Sylvan is <a class="reference external" href="https://github.com/trolando/sylvan">https://github.com/trolando/sylvan</a>. A
mirror is available at <a class="reference external" href="https://github.com/utwente-fmt/sylvan">https://github.com/utwente-fmt/sylvan</a>.</p>
<p>Bindings for other languages than C/C++ also exist:</p>
<ul class="simple">
<li><p>Java/JNI bindings: <a class="reference external" href="https://github.com/utwente-fmt/jsylvan">https://github.com/utwente-fmt/jsylvan</a></p></li>
<li><p>Haskell bindings: <a class="reference external" href="https://github.com/adamwalker/sylvan-haskell">https://github.com/adamwalker/sylvan-haskell</a></p></li>
<li><p>Python bindings: <a class="reference external" href="https://github.com/johnyf/dd">https://github.com/johnyf/dd</a></p></li>
</ul>
<section id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this heading">¶</a></h2>
<p>Sylvan has the following dependencies:</p>
<ul class="simple">
<li><p><strong>CMake</strong> for compiling.</p></li>
<li><p><strong>gmp</strong> (<code class="docutils literal notranslate"><span class="pre">libgmp-dev</span></code>) for the GMP leaves in MTBDDs.</p></li>
<li><p><strong>Sphinx</strong> if you want to build the documentation.</p></li>
</ul>
<p>Sylvan depends on the <a class="reference external" href="http://fmt.ewi.utwente.nl/tools/lace">work-stealing framework
Lace</a> for its implementation.
Lace is embedded in the Sylvan distribution.
Lace requires one additional library:</p>
<ul class="simple">
<li><p><strong>hwloc</strong> (<code class="docutils literal notranslate"><span class="pre">libhwloc-dev</span></code>) for pinning worker threads to processors.</p></li>
</ul>
</section>
<section id="building">
<h2>Building<a class="headerlink" href="#building" title="Permalink to this heading">¶</a></h2>
<p>It is recommended to build Sylvan in a separate build directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>..
make<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make<span class="w"> </span><span class="nb">test</span>
</pre></div>
</div>
<p>It is recommended to use <code class="docutils literal notranslate"><span class="pre">ccmake</span></code> to configure the build settings of Sylvan. These include, e.g.,
enabling gathering of statistics and selecting whether you want a <code class="docutils literal notranslate"><span class="pre">Debug</span></code> or a <code class="docutils literal notranslate"><span class="pre">Release</span></code> build.
The resulting artifact is a static library residing at <code class="docutils literal notranslate"><span class="pre">build/src/libsylvan.a</span></code>.</p>
</section>
<section id="using-sylvan">
<h2>Using Sylvan<a class="headerlink" href="#using-sylvan" title="Permalink to this heading">¶</a></h2>
<p>To use Sylvan, the library and its dependency Lace must be initialized:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sylvan.h&gt;</span>

<span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n_workers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// auto-detect</span>
<span class="w">    </span><span class="n">lace_start</span><span class="p">(</span><span class="n">n_workers</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// use at most 512 MB, nodes:cache ratio 2:1, initial size 1/32 of maximum</span>
<span class="w">    </span><span class="n">sylvan_set_limits</span><span class="p">(</span><span class="mi">512</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">sylvan_init_package</span><span class="p">();</span>
<span class="w">    </span><span class="n">sylvan_init_mtbdd</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* ... do stuff ... */</span>

<span class="w">    </span><span class="n">sylvan_stats_report</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="w">    </span><span class="n">sylvan_quit</span><span class="p">();</span>
<span class="w">    </span><span class="n">lace_stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">lace_start</span></code> initializes the Lace framework, setting up the necessary data structures
for work-stealing. The function also spawns <code class="docutils literal notranslate"><span class="pre">n_workers</span></code> worker threads that will execute all
Sylvan tasks. Setting <code class="docutils literal notranslate"><span class="pre">n_workers</span></code> to 0 means that the number of workers will be auto-detected.
Lace must be started before Sylvan can be initialized. The worker threads will busy-wait until a
task is offered, e.g. <cite>mtbdd_applyp</cite> is called, from a non-worker (main) thread. The worker threads
can be suspended by calling <code class="docutils literal notranslate"><span class="pre">lace_suspend</span></code>, preventing high CPU utilization when the application
using Sylvan has no *BDD-related work to do. The worker threads can be later resumed by calling
<code class="docutils literal notranslate"><span class="pre">lace_resume</span></code>.  Calling <code class="docutils literal notranslate"><span class="pre">lace_stop</span></code> terminates all the worker threads.</p>
<p>Sylvan is initialized with a call to <code class="docutils literal notranslate"><span class="pre">sylvan_init_package</span></code>. Before this call, Sylvan needs to know
how much memory to allocate for the nodes table and the operation cache. In this example, we use the
<code class="docutils literal notranslate"><span class="pre">sylvan_set_limits</span></code> function to tell Sylvan that it may allocate at most 512 MB for these tables.
The second parameter indicates the ratio of the nodes table and the operation cache, with each
higher number doubling the size of the nodes table. Negative numbers double the size of the operation
cache instead. In the example, we want the nodes table to be twice as big as the operation cache.
The third parameter controls how often garbage collection doubles the table sizes before
their maximum size is reached. The value 5 means that the initial tables are 32x as small as the maximum size.
By default, every execution of garbage collection doubles the table sizes.</p>
<p>After <code class="docutils literal notranslate"><span class="pre">sylvan_init_package</span></code>, subpackages like <code class="docutils literal notranslate"><span class="pre">mtbdd</span></code> and <code class="docutils literal notranslate"><span class="pre">ldd</span></code> can be initialized with
<code class="docutils literal notranslate"><span class="pre">sylvan_init_mtbdd</span></code> and <code class="docutils literal notranslate"><span class="pre">sylvan_init_ldd</span></code>. This allocates auxiliary datastructures.</p>
<p>If you enabled statistics generation (via CMake), then you can use <code class="docutils literal notranslate"><span class="pre">sylvan_stats_report</span></code> to report
the obtained statistics to a given <code class="docutils literal notranslate"><span class="pre">FILE*</span></code>.</p>
<section id="the-lace-framework">
<h3>The Lace framework<a class="headerlink" href="#the-lace-framework" title="Permalink to this heading">¶</a></h3>
<p>Sylvan uses the Lace framework to offer ‘automatic’ parallelization of decision diagram operations.
Many functions in Sylvan are Lace tasks that can be executed only from lace (worker) threads.
Functions provided by Sylvan are internally wrapped in a <code class="docutils literal notranslate"><span class="pre">RUN</span></code> macro that will offer a task to
lace workers and block the execution of the thread calling the function, thus, no special handling
is required when calling Sylvan functions.</p>
</section>
<section id="garbage-collection-and-referencing-nodes">
<h3>Garbage collection and referencing nodes<a class="headerlink" href="#garbage-collection-and-referencing-nodes" title="Permalink to this heading">¶</a></h3>
<p>Like all decision diagram implementations, Sylvan performs garbage collection.
Garbage collection is triggered when trying to insert a new node and no
empty space can be found in the table within a reasonable upper bound.</p>
<p>Garbage collection can be disabled with <code class="docutils literal notranslate"><span class="pre">sylvan_gc_disable</span></code> and enabled again with <code class="docutils literal notranslate"><span class="pre">sylvan_gc_enable</span></code>.
Call <code class="docutils literal notranslate"><span class="pre">sylvan_gc</span></code> to manually trigger garbage collection.</p>
<p>To ensure that no decision diagram nodes are overwritten, you must ensure that
Sylvan knows which decision diagrams you care about.
Each subpackage implements mechanisms to store references to decision diagrams that must be kept.
For example, the <em>mtbdd</em> subpackage implements <code class="docutils literal notranslate"><span class="pre">mtbdd_protect</span></code> and <code class="docutils literal notranslate"><span class="pre">mtbdd_unprotect</span></code> to store pointers to
MTBDD variables.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MTBDD</span><span class="o">*</span><span class="w"> </span><span class="nf">allocate_var</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MTBDD</span><span class="o">*</span><span class="w"> </span><span class="n">my_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">MTBDD</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MTBDD</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">mtbdd_protect</span><span class="p">(</span><span class="n">my_var</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">my_var</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">free_var</span><span class="p">(</span><span class="n">MTBDD</span><span class="o">*</span><span class="w"> </span><span class="n">my_var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mtbdd_unprotect</span><span class="p">(</span><span class="n">my_var</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">my_var</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you use <code class="docutils literal notranslate"><span class="pre">mtbdd_protect</span></code> you do not need to update the reference every time the value changes.</p>
<p>The <em>mtbdd</em> subpackage also implements thread-local stacks to temporarily store pointers and results of tasks:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MTBDD</span><span class="w"> </span><span class="n">some_thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">mtbdd_refs_pushptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">some_thing</span><span class="p">);</span>
<span class="n">MTBDD</span><span class="w"> </span><span class="n">result_param1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mtbdd_false</span><span class="p">,</span><span class="w"> </span><span class="n">result_param2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mtbdd_false</span><span class="p">;</span>
<span class="n">mtbdd_refs_pushptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result_param1</span><span class="p">);</span>
<span class="n">mtbdd_refs_pushptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result_param2</span><span class="p">);</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">some_condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mtbdd_refs_spawn</span><span class="p">(</span><span class="n">SPAWN</span><span class="p">(</span><span class="n">an_operation</span><span class="p">,</span><span class="w"> </span><span class="n">some_thing</span><span class="p">,</span><span class="w"> </span><span class="n">param1</span><span class="p">));</span>
<span class="w">    </span><span class="n">result_param2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CALL</span><span class="p">(</span><span class="n">an_operation</span><span class="p">,</span><span class="w"> </span><span class="n">some_thing</span><span class="p">,</span><span class="w"> </span><span class="n">param2</span><span class="p">);</span>
<span class="w">    </span><span class="n">result_param1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mtbdd_refs_sync</span><span class="p">(</span><span class="n">SYNC</span><span class="p">(</span><span class="n">an_operation</span><span class="p">));</span>
<span class="w">    </span><span class="n">some_thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CALL</span><span class="p">(</span><span class="n">another_operation</span><span class="p">,</span><span class="w"> </span><span class="n">result1</span><span class="p">,</span><span class="w"> </span><span class="n">result2</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">mtbdd_refs_popptr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="n">some_thing</span><span class="p">;</span>
</pre></div>
</div>
<p>It is recommended to use the thread-local stacks for local variables, and to use the <code class="docutils literal notranslate"><span class="pre">protect</span></code> and <code class="docutils literal notranslate"><span class="pre">unprotect</span></code>
functions for other variables. Every SPAWN and SYNC of a Lace task that returns an MTBDD must be decorated with
<code class="docutils literal notranslate"><span class="pre">mtbdd_refs_stack</span></code> and <code class="docutils literal notranslate"><span class="pre">mtbdd_refs_sync</span></code> as in the above example.</p>
<p>References to decision diagrams must be added before a worker may cooperate on garbage collection.
Workers can cooperate on garbage collection during <code class="docutils literal notranslate"><span class="pre">SYNC</span></code> and when functions create nodes or use <code class="docutils literal notranslate"><span class="pre">sylvan_gc_test</span></code> to test whether to assist in garbage collection.
Functions for adding or removing references never perform garbage collection.
Furthermore, only the <code class="docutils literal notranslate"><span class="pre">mtbdd_makenode</span></code> function (and other node making primitives) implicitly reference their parameters; all other functions do not reference their parameters.
Nesting Sylvan functions (including <code class="docutils literal notranslate"><span class="pre">sylvan_ithvar</span></code>) is bad practice and should be avoided.</p>
<p><strong>Warning</strong>: Sylvan is a multi-threaded library and all workers must cooperate for garbage collection. If you use locking mechanisms in your code, beware of deadlocks!
You can explicitly cooperate on garbage collection with <code class="docutils literal notranslate"><span class="pre">sylvan_gc_test()</span></code>.</p>
</section>
<section id="basic-bdd-mtbdd-functionality">
<h3>Basic BDD/MTBDD functionality<a class="headerlink" href="#basic-bdd-mtbdd-functionality" title="Permalink to this heading">¶</a></h3>
<p>In Sylvan, BDDs are special cases of MTBDDs.
Several functions are specific for BDDs and they start with <code class="docutils literal notranslate"><span class="pre">sylvan_</span></code>, whereas generic MTBDD functions start
with <code class="docutils literal notranslate"><span class="pre">mtbdd_</span></code>.</p>
<p>To create new BDDs, you can use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_true</span></code>: representation of constant <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_false</span></code>: representation of constant <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_ithvar(var)</span></code>: representation of literal &lt;var&gt; (negated: <code class="docutils literal notranslate"><span class="pre">sylvan_nithvar(var)</span></code>)</p></li>
</ul>
<p>To follow the BDD edges and obtain the variable at the root of a BDD,
you can use (only for internal nodes, not for leaves <code class="docutils literal notranslate"><span class="pre">mtbdd_true</span></code> and <code class="docutils literal notranslate"><span class="pre">mtbdd_false</span></code>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_getvar(bdd)</span></code>: obtain the variable of the root node of &lt;bdd&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_gethigh(bdd)</span></code>: follow the high edge of &lt;bdd&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_getlow(bdd)</span></code>: follow the low edge of &lt;bdd&gt;.</p></li>
</ul>
<p>You need to manually reference BDDs that you want to keep during garbage
collection (see the above explanation):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_protect(bddptr)</span></code>: add a pointer reference to &lt;bddptr&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_unprotect(bddptr)</span></code>: remove a pointer reference to &lt;bddptr&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_refs_pushptr(bddptr)</span></code>: add a local pointer reference to &lt;bddptr&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_refs_popptr(amount)</span></code>: remove the last &lt;amount&gt; local pointer references.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_refs_spawn(SPAWN(...))</span></code>: spawn a task that returns a BDD/MTBDD.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_refs_sync(SYNC(...))</span></code>: sync a task that returns a BDD/MTBDD.</p></li>
</ul>
<p>It is recommended to use <code class="docutils literal notranslate"><span class="pre">mtbdd_protect</span></code> and <code class="docutils literal notranslate"><span class="pre">mtbdd_unprotect</span></code>.
The C++ objects (defined in <code class="docutils literal notranslate"><span class="pre">sylvan_obj.hpp</span></code>) handle this automatically.
For local variables, we recommend <code class="docutils literal notranslate"><span class="pre">mtbdd_refs_pushptr</span></code> and <code class="docutils literal notranslate"><span class="pre">mtbdd_refs_popptr</span></code>.</p>
<p>The following basic BDD operations are implemented:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_not(bdd)</span></code>: compute the negation of &lt;bdd&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_ite(a,b,c)</span></code>: compute ‘if &lt;a&gt; then &lt;b&gt; else &lt;c&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_and(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;a&gt; and &lt;b&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_or(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;a&gt; or &lt;b&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_nand(a,</span> <span class="pre">b)</span></code>: compute ‘not (&lt;a&gt; and &lt;b&gt;)’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_nor(a,</span> <span class="pre">b)</span></code>: compute ‘not (&lt;a&gt; or &lt;b&gt;)’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_imp(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;a&gt; then &lt;b&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_invimp(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;b&gt; then &lt;a&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_xor(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;a&gt; xor &lt;b&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_equiv(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;a&gt; = &lt;b&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_diff(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;a&gt; and not &lt;b&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_less(a,</span> <span class="pre">b)</span></code>: compute ‘&lt;b&gt; and not &lt;a&gt;’.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_exists(bdd,</span> <span class="pre">vars)</span></code>: existential quantification of &lt;bdd&gt; with respect to variables &lt;vars&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_forall(bdd,</span> <span class="pre">vars)</span></code>: universal quantification of &lt;bdd&gt; with respect to variables &lt;vars&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_project(bdd,</span> <span class="pre">vars)</span></code>: the dual of <code class="docutils literal notranslate"><span class="pre">sylvan_exists</span></code>, projects the &lt;bdd&gt; to the variable domain &lt;vars&gt;.</p></li>
</ul>
<p>A set of variables (like &lt;vars&gt; above) is a BDD representing the conjunction of the variables.
A number of convencience functions are defined to manipulate sets of variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_empty()</span></code>: obtain an empty set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_isempty(set)</span></code>: compute whether the set is empty.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_first(set)</span></code>: obtain the first variable of the set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_next(set)</span></code>: obtain the subset without the first variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_from_array(arr,</span> <span class="pre">len)</span></code>: create a set from a given array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_to_array(set,</span> <span class="pre">arr)</span></code>: write the set to the given array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_add(set,</span> <span class="pre">var)</span></code>: compute the set plus the variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_union(set1,</span> <span class="pre">set2)</span></code>: compute the union of two sets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_remove(set,</span> <span class="pre">var)</span></code>: compute the set minus the variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_minus(set1,</span> <span class="pre">set2)</span></code>: compute the set &lt;set1&gt; minus the variables in &lt;set2&gt;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_count(set)</span></code>: compute the number of variables in the set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_set_contains(set,</span> <span class="pre">var)</span></code>: compute whether the set contains the variable.</p></li>
</ul>
<p>Sylvan also implements composition and substitution/variable renaming using a “MTBDD map”. An MTBDD map is a special structure
implemented with special MTBDD nodes to store a mapping from variables (uint32_t) to MTBDDs. Like sets of variables and MTBDDs, MTBDD maps must
also be referenced for garbage collection. The following functions are related to MTBDD maps:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_compose(dd,</span> <span class="pre">map)</span></code>: apply the map to the given decision diagram, transforming every node with a variable that is associated with some function F in the map by <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">&lt;F&gt;</span> <span class="pre">then</span> <span class="pre">&lt;high&gt;</span> <span class="pre">else</span> <span class="pre">&lt;low&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_compose(dd,</span> <span class="pre">map)</span></code>: same as <code class="docutils literal notranslate"><span class="pre">mtbdd_compose</span></code>, but assumes the decision diagram only has Boolean leaves.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_empty()</span></code>: obtain an empty map.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_isempty(map)</span></code>: compute whether the map is empty.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_key(map)</span></code>: obtain the key of the first pair of the map.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_value(map)</span></code>: obtain the value of the first pair of the map.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_next(map)</span></code>: obtain the submap without the first pair.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_add(map,</span> <span class="pre">key,</span> <span class="pre">value)</span></code>: compute the map plus the given key-value pair.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_update(map1,</span> <span class="pre">map2)</span></code>: compute the union of two maps, with priority to map2 if both maps share variables.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_remove(map,</span> <span class="pre">var)</span></code>: compute the map minus the variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_removeall(map,</span> <span class="pre">set)</span></code>: compute the map minus the given variables.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_count(set)</span></code>: compute the number of pairs in the map.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_map_contains(map,</span> <span class="pre">var)</span></code>: compute whether the map contains the variable.</p></li>
</ul>
<p>Sylvan implements a number of counting operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_satcount(bdd,</span> <span class="pre">number_of_vars)</span></code>: compute the number of minterms (assignments that lead to True) for a function with &lt;number_of_vars&gt; variables; we don’t need to know the exact variables that may be in the BDD, just how many there are.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_pathcount(bdd)</span></code>: compute the number of distinct paths to True.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_nodecount(bdd)</span></code>: compute the number of nodes (and leaves) in the BDD.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtbdd_nodecount_more(array,</span> <span class="pre">length)</span></code>: compute the number of nodes (and leaves) in the array of BDDs.</p></li>
</ul>
<p>Sylvan implements various advanced operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_and_exists(bdd_a,</span> <span class="pre">bdd_b,</span> <span class="pre">vars)</span></code>: compute <code class="docutils literal notranslate"><span class="pre">sylvan_exists(sylvan_and(bdd_a,</span> <span class="pre">bdd_b),</span> <span class="pre">vars)</span></code> in one step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_and_project(bdd_a,</span> <span class="pre">bdd_b,</span> <span class="pre">vars)</span></code>: compute <code class="docutils literal notranslate"><span class="pre">sylvan_project(sylvan_and(bdd_a,</span> <span class="pre">bdd_b),</span> <span class="pre">vars)</span></code> in one step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_cube(vars,</span> <span class="pre">values)</span></code>: compute a cube (to leaf True) of the given variables, where the array values indicates for each variable whether to use it in negative form (value 0) or positive form (value 1) or to skip it (as dont-care, value 2).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_union_cube(set,</span> <span class="pre">vars,</span> <span class="pre">values)</span></code>: compute <code class="docutils literal notranslate"><span class="pre">sylvan_or(set,</span> <span class="pre">sylvan_cube(vars,</span> <span class="pre">values))</span></code> in one step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_constrain(bdd_f,</span> <span class="pre">bdd_c)</span></code>: compute the generic cofactor of F constrained by C, i.e, set F to False for all assignments not in C.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_restrict(bdd_f,</span> <span class="pre">bdd_c)</span></code>: compute Coudert and Madre’s restrict algorithm, which tries to minimize bdd_f according to a care set C using sibling substitution; the invariant is <code class="docutils literal notranslate"><span class="pre">restrict(f,</span> <span class="pre">c)</span> <span class="pre">\and</span> <span class="pre">c</span> <span class="pre">==</span> <span class="pre">f</span> <span class="pre">\and</span> <span class="pre">c</span></code>; the result of this algorithm is often but not always smaller than the original.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_pick_cube(bdd)</span></code> or <code class="docutils literal notranslate"><span class="pre">sylvan_sat_one_bdd(bdd)</span></code>: extract a single path to True from the BDD (returns the BDD of this path)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_pick_single_cube(bdd,</span> <span class="pre">vars)</span></code> or <code class="docutils literal notranslate"><span class="pre">sylvan_sat_single(bdd,</span> <span class="pre">vars)</span></code> extracts a single minterm from the BDD (returns the BDD of this assignment)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_sat_one(bdd,</span> <span class="pre">vars,</span> <span class="pre">array)</span></code>: extract a single minterm from the BDD given the set of variables and write the values of the variables in order to the given array, with 0 when it is negative, 1 when it is positive, and 2 when it is dontcare.</p></li>
</ul>
<p>Sylvan implements several operations for transition systems. These operations assume an interleaved variable ordering, such that <em>source</em> or <em>unprimed</em> variables have even parity (0, 2, 4…) and matching <em>target</em> or <em>primed</em> variables have odd parity (1, 3, 5…).
The transition relations may be partial transition relations that only manipulate a subset of variables; hence, the operations also require the set of variables.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_relnext(set,</span> <span class="pre">relation,</span> <span class="pre">vars)</span></code>: apply the (partial) relation on the given variables to the set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_relprev(relation,</span> <span class="pre">set,</span> <span class="pre">vars)</span></code>: apply the (partial) relation in reverse to the set; this computes predecessors but can also concatenate relations as follows: <code class="docutils literal notranslate"><span class="pre">sylvan_relprev(rel1,</span> <span class="pre">rel2,</span> <span class="pre">rel1_vars)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sylvan_closure(relation)</span></code>: compute the transitive closure of the given set recursively (see Matsunaga et al, DAC 1993)</p></li>
</ul>
<p>See <code class="docutils literal notranslate"><span class="pre">src/sylvan_bdd.h</span></code> and <code class="docutils literal notranslate"><span class="pre">src/mtbdd.h</span></code> for other operations on BDDs and MTBDDs.</p>
</section>
<section id="custom-leaves">
<h3>Custom leaves<a class="headerlink" href="#custom-leaves" title="Permalink to this heading">¶</a></h3>
<p>See <code class="docutils literal notranslate"><span class="pre">src/sylvan_mt.h</span></code> and the example in <code class="docutils literal notranslate"><span class="pre">src/sylvan_gmp.h</span></code> and <code class="docutils literal notranslate"><span class="pre">src/sylvan_gmp.c</span></code> for custom leaves in MTBDDs.</p>
</section>
<section id="custom-decision-diagram-operations">
<h3>Custom decision diagram operations<a class="headerlink" href="#custom-decision-diagram-operations" title="Permalink to this heading">¶</a></h3>
<p>Adding custom decision diagram operations is easy. Include <code class="docutils literal notranslate"><span class="pre">sylvan_int.h</span></code> for the internal functions. See <code class="docutils literal notranslate"><span class="pre">sylvan_cache.h</span></code>
for how to use the operation cache.</p>
</section>
<section id="list-decision-diagrams">
<h3>List decision diagrams<a class="headerlink" href="#list-decision-diagrams" title="Permalink to this heading">¶</a></h3>
<p>See <code class="docutils literal notranslate"><span class="pre">src/sylvan_ldd.h</span></code> for operations on list decision diagrams.</p>
</section>
<section id="file-i-o">
<h3>File I/O<a class="headerlink" href="#file-i-o" title="Permalink to this heading">¶</a></h3>
<p>You can store and load BDDs using a number of methods, which are documented in the header files <code class="docutils literal notranslate"><span class="pre">sylvan_mtbdd.h</span></code> and <code class="docutils literal notranslate"><span class="pre">sylvan_ldd.h</span></code>.</p>
</section>
<section id="support-for-c">
<h3>Support for C++<a class="headerlink" href="#support-for-c" title="Permalink to this heading">¶</a></h3>
<p>See <code class="docutils literal notranslate"><span class="pre">src/sylvan_obj.hpp</span></code> for the C++ interface.</p>
</section>
<section id="table-resizing">
<h3>Table resizing<a class="headerlink" href="#table-resizing" title="Permalink to this heading">¶</a></h3>
<p>During garbage collection, it is possible to resize the nodes table and
the cache. By default, Sylvan doubles the table sizes during every garbage
collection until the maximum table size has been reached. There is also a
less aggressive version that only resizes when at least half the table is
full. This can be configured in <code class="docutils literal notranslate"><span class="pre">src/sylvan_config.h</span></code>. It is not
possible to decrease the size of the nodes table and the cache.</p>
</section>
<section id="dynamic-reordering">
<h3>Dynamic reordering<a class="headerlink" href="#dynamic-reordering" title="Permalink to this heading">¶</a></h3>
<p>Dynamic reordening is not yet supported. For now, we suggest users
find a good static variable ordering.</p>
</section>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<p>Simple examples can be found in the <code class="docutils literal notranslate"><span class="pre">examples</span></code> subdirectory. The file
<code class="docutils literal notranslate"><span class="pre">simple.cpp</span></code> contains a toy program that uses the C++ objects to
perform basic BDD manipulation. The <code class="docutils literal notranslate"><span class="pre">mc.c</span></code> and <code class="docutils literal notranslate"><span class="pre">lddmc.c</span></code> programs
are more advanced examples of symbolic model checking (with example
models in the <code class="docutils literal notranslate"><span class="pre">models</span></code> subdirectory).</p>
</section>
<section id="troubleshooting">
<h2>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this heading">¶</a></h2>
<p>Sylvan may require a larger than normal program stack. You may need to
increase the program stack size on your system using <code class="docutils literal notranslate"><span class="pre">ulimit</span> <span class="pre">-s</span></code>.
Segmentation faults on large computations typically indicate a program
stack overflow.</p>
<section id="i-am-getting-the-error-unable-to-allocate-memory">
<h3>I am getting the error “unable to allocate memory: …!”<a class="headerlink" href="#i-am-getting-the-error-unable-to-allocate-memory" title="Permalink to this heading">¶</a></h3>
<p>Sylvan allocates virtual memory using mmap. If you specify a combined
size for the cache and node table larger than your actual available
memory you may need to set <code class="docutils literal notranslate"><span class="pre">vm.overcommit_memory</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>. E.g.
<code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">/proc/sys/vm/overcommit_memory</span></code>. You can make this setting
permanent with
<code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">&quot;vm.overcommit_memory</span> <span class="pre">=</span> <span class="pre">1&quot;</span> <span class="pre">&gt;</span> <span class="pre">/etc/sysctl.d/99-sylvan.conf</span></code>. You
can verify the setting with <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/proc/sys/vm/overcommit_memory</span></code>. It
should report <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</section>
<section id="i-get-errors-about-lace-worker-and-lace-dq-head">
<h3>I get errors about <code class="docutils literal notranslate"><span class="pre">__lace_worker</span></code> and <code class="docutils literal notranslate"><span class="pre">__lace_dq_head</span></code><a class="headerlink" href="#i-get-errors-about-lace-worker-and-lace-dq-head" title="Permalink to this heading">¶</a></h3>
<p>Many Sylvan operations are implemented as Lace tasks. To call a Lace
task, the variables <code class="docutils literal notranslate"><span class="pre">__lace_worker</span></code> and <code class="docutils literal notranslate"><span class="pre">__lace_dq_head</span></code> must be
initialized. Use the macro <code class="docutils literal notranslate"><span class="pre">LACE_ME</span></code> to do this. Only use <code class="docutils literal notranslate"><span class="pre">LACE_ME</span></code>
locally (in a function), never globally!</p>
</section>
</section>
<section id="publications">
<h2>Publications<a class="headerlink" href="#publications" title="Permalink to this heading">¶</a></h2>
<p>T. van Dijk (2016) <a class="reference external" href="http://dx.doi.org/10.3990/1.9789036541602">Sylvan: Multi-core Decision
Diagrams</a>. PhD Thesis.</p>
<p>T. van Dijk and J.C. van de Pol (2016) <a class="reference external" href="http://dx.doi.org/10.1007/s10009-016-0433-2">Sylvan: Multi-core Framework
for Decision Diagrams</a>.
In: STTT (Special Issue), Springer.</p>
<p>T. van Dijk and J.C. van de Pol (2015) <a class="reference external" href="http://dx.doi.org/10.1007/978-3-662-46681-0_60">Sylvan: Multi-core Decision
Diagrams</a>. In: TACAS
2015, LNCS 9035. Springer.</p>
<p>T. van Dijk and A.W. Laarman and J.C. van de Pol (2012) <a class="reference external" href="http://eprints.eemcs.utwente.nl/22166/">Multi-Core BDD
Operations for Symbolic
Reachability</a>. In: PDMC 2012,
ENTCS. Elsevier.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, University of Twente.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>